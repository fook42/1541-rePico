/**********************************
 * header - main routines, defines, variables
 *
 * Author: F00K42
 * Last change: 2026/01/16
***********************************/
#include "hw_config.h"
#include "f_util.h"
#include "ff.h"

/////
#define LCD_LINE_COUNT  (LCD_ROWS)
#define LCD_LINE_SIZE   (LCD_COLS)

// Spur auf dem der Lesekopf beim Start/Reset stehen soll
// Track 18 --> Directory
#define INIT_TRACK  (18)

// functions

void check_stepper_signals(void);
void check_motor_signal(void);
uint8_t get_key_from_buffer(void);
void update_gui(void);
void check_menu_events(const uint16_t menu_event);
void set_gui_mode(const uint8_t gui_mode);
void filebrowser_update(uint8_t key_code);
void filebrowser_refresh(void);

uint16_t get_dir_entry_count(void);
uint16_t seek_to_dir_entry(uint16_t entry_num);

void show_start_message(void);

void init_stepper(void);
void stepper_inc(void);
void stepper_dec(void);
void init_motor(void);
void init_control_signals(void);
void soe_gatearray_init(void);

void open_disk_image(FIL* fd, FILINFO *file_entry, uint8_t* image_type);
void close_disk_image(FIL* fd);
void open_g64_image(FIL* fd);
void open_d64_image(FIL* fd);
int8_t read_disk(FIL* fd, const int image_type);

void set_write_protection(bool wp);
void send_disk_change(void);

bool repeating_timer_callback(__unused struct repeating_timer *t);
void init_bytetimer(void);
void start_bytetimer(void);
void stop_bytetimer(void);

/////////////

// Filesystem-variables:
FATFS       fs;             // filesystem handle - only created once
FRESULT     fr;             // general purpos result variable
DIR         dir_object;
FIL         fd;             // file descriptor for every open file
FILINFO     dir_entry;
FILINFO     file_entry;
FILINFO     fb_dir_entry[LCD_LINE_COUNT];
//


volatile uint8_t akt_gcr_byte = 0;
volatile uint16_t akt_track_pos = 0;

uint8_t akt_half_track;
uint8_t old_half_track;


const uint16_t d64_track_offset[43] = {0,0x0000,0x0015,0x002A,0x003F,0x0054,0x0069,0x007E,0x0093,
                                         0x00A8,0x00BD,0x00D2,0x00E7,0x00FC,0x0111,0x0126,0x013B,
                                         0x0150,0x0165,0x0178,0x018B,0x019E,0x01B1,0x01C4,0x01D7,
                                         0x01EA,0x01FC,0x020E,0x0220,0x0232,0x0244,0x0256,0x0267,
                                         0x0278,0x0289,0x029A,0x02AB,0x02BC,0x02CD,0x02DE,0x02EF,
                                         0x0300,0x0311 };

const uint8_t d64_sector_count[4] = {21,        //Spuren 1-17
                                     19,        //Spuren 18-24
                                     18,        //Spuren 25-30
                                     17};       //Spuren 31-42

const uint8_t d64_track_zone[43] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,                    //Spuren 1-17
                               1,1,1,1,1,1,1,                                               //Spuren 18-24
                               2,2,2,2,2,2,                                                 //Spuren 25-30
                               3,3,3,3,3,3,3,3,3,3,3,3};                                    //Spuren 31-42

#define D64_SECTOR_SIZE (256)
uint8_t d64_sector_puffer[21*D64_SECTOR_SIZE+5];


#define GCR_SYNCMARK    (0xFF)
// *** definition of GCR-structure
// see: https://ist.uwaterloo.ca/~schepers/formats/G64.TXT

#define G64_VERSION     (0x00)
#define G64_TRACKCOUNT  (42)
#define G64_TRACKSIZE   (7928)  // = 0x1ef8

const uint8_t g64_head[] = {'G','C','R','-','1','5','4','1', G64_VERSION, G64_TRACKCOUNT*2, (G64_TRACKSIZE&0xff), ((G64_TRACKSIZE>>8)&0xff)};
uint32_t g64_jumptable[2*G64_TRACKCOUNT];
/* = {                                                                  0xac, 0x02, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xa6, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x40, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x9a, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x7e, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x8e, 0x9d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0xbc, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x82, 0xdb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xfa, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x76, 0x19, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x38, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x6a, 0x57, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x76, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x5e, 0x95, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0xb4, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x52, 0xd3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0xf2, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x46, 0x11, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x30, 0x02, 0x00,
0x00, 0x00, 0x00, 0x00, 0x3a, 0x4f, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x6e, 0x02, 0x00,
0x00, 0x00, 0x00, 0x00, 0x2e, 0x8d, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0xac, 0x02, 0x00,
0x00, 0x00, 0x00, 0x00, 0x22, 0xcb, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0xea, 0x02, 0x00,
0x00, 0x00, 0x00, 0x00, 0x16, 0x09, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x28, 0x03, 0x00,
0x00, 0x00, 0x00, 0x00, 0x0a, 0x47, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x66, 0x03, 0x00,
0x00, 0x00, 0x00, 0x00, 0xfe, 0x84, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xa3, 0x03, 0x00,
0x00, 0x00, 0x00, 0x00, 0xf2, 0xc2, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xec, 0xe1, 0x03, 0x00,
0x00, 0x00, 0x00, 0x00, 0xe6, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0x04, 0x00,
0x00, 0x00, 0x00, 0x00, 0xda, 0x3e, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd4, 0x5d, 0x04, 0x00,
0x00, 0x00, 0x00, 0x00, 0xce, 0x7c, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x9b, 0x04, 0x00,
0x00, 0x00, 0x00, 0x00, 0xc2, 0xba, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0xd9, 0x04, 0x00,
0x00, 0x00, 0x00, 0x00, 0xb6, 0xf8, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00};
*/

uint32_t g64_speedtable[2*G64_TRACKCOUNT];
/* = {                                                                  0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
*/

const uint8_t g64_speedzones[] = { 3, 2, 1, 0};

#define G64_HEADERSIZE (sizeof(g64_head)+sizeof(g64_jumptable)+sizeof(g64_speedtable)) // should be 684 bytes

uint16_t g64_tracklen[G64_TRACKCOUNT];

// enough space to store 42 tracks, each 7928 bytes byte length
uint8_t g64_tracks[G64_TRACKCOUNT][G64_TRACKSIZE];

// timer definition

struct repeating_timer bytetimer;
// Originale Bitraten
//Zone 0: 8000000/26 = 307692 Hz    (ByteReady 38461.5 Hz)
//Zone 1: 8000000/28 = 285714 Hz    (ByteReady 35714.25 Hz)
//Zone 2: 8000000/30 = 266667 Hz    (ByteReady 33333.375 Hz)
//Zone 3: 8000000/32 = 250000 Hz    (ByteReady 31250 Hz)

//Höhere Werte verlangsammen die Bitrate (=us delay-values between bytes)
const int64_t bytetimer_values[4] = {26, 28, 30, 32};

// Zeit die nach der letzten Stepperaktivität vergehen muss, um einen neuen Track von SD Karte zu laden
// (1541 Original Rom schaltet STP1 alle 15ms)
// Default 15
#define STEPPER_DELAY_TIME 193  // zwischen 26µs*193=5,02ms bis 32µs*160=6,176ms

const uint8_t d64_sector_gap[4] = {12, 21, 16, 13}; // von GPZ Code übermommen imggen
#define HEADER_GAP_BYTES (9)

char image_filename[256]; //Maximal 256 Zeichen

uint8_t current_gui_mode;

uint8_t gui_current_line_offset;         // >0 dann ist der Name länger als die maximale Anzeigelaenge
uint8_t gui_line_scroll_pos;             // Kann zwischen 0 und fb_current_line_offset liegen
uint8_t gui_line_scroll_direction;       // Richtung des Scrollings
uint8_t gui_line_scroll_end_begin_wait;

// Alles für den FilebrowserSS
uint16_t fb_dir_entry_count = 0;         // Anzahl der Einträge im aktuellen Direktory
uint8_t fb_cursor_pos = 0;               // Position des Cursors auf dem LCD Display
uint8_t fb_window_pos = 0;               // Position des Anzeigebereichs innerhablb der Menüeinträge

uint8_t fb_current_line_offset = 0;         // >0 dann ist der Name länger als die maximale Anzeigelaenge
uint8_t fb_line_scroll_pos = 0;             // Kann zwischen 0 und fb_current_line_offset liegen
uint8_t fb_line_scroll_direction = 0;       // Richtung des Scrollings
uint8_t fb_line_scroll_end_begin_wait = 10;

uint8_t id1 = 0;    // id1 and id2 identify a floppy-disk
uint8_t id2 = 0;    // - these need to change to .. signal a disk-change or after a format...

enum {UNDEF_IMAGE, G64_IMAGE, D64_IMAGE};

// floppydisk emulation
uint8_t akt_image_type = UNDEF_IMAGE;     // 0=kein Image, 1=G64, 2=D64
bool is_image_mount;

uint8_t is_wps_pin_enable = 0; // 0=WPS PIN=HiZ / 1=WPS Output
bool floppy_wp = true;  // Hier wird der aktuelle WriteProtection Zustand gespeichert
                        // false=Nicht Schreibgeschützt , true=Schreibgeschützt

#define set_byte_ready()    gpio_set_dir(GPIO_BRDY,GPIO_IN)    // HiZ
#define clear_byte_ready()  {gpio_set_dir(GPIO_BRDY,GPIO_OUT);gpio_put(GPIO_BRDY,false);}   // auf Ground ziehen

#define get_soe_status()    gpio_get(GPIO_SOE)

#define get_so_status()     gpio_get(GPIO_OE)

#define set_soe_gatearray()     gpio_put(GPIO_SOE_GA,true)
#define clear_soe_gatearray()   gpio_put(GPIO_SOE_GA,false)


#define set_wps()           gpio_put(GPIO_WPS,true)     // 5V Level = WritePotect
#define clear_wps()         gpio_put(GPIO_WPS,false)    // 0V Level = Writeable

#define get_motor_status()  gpio_get(GPIO_MTR)

#define set_sync()          gpio_put(GPIO_SYNC,true)
#define clear_sync()        gpio_put(GPIO_SYNC,false)

#define out_gcr_byte(gcr_byte)  gpio_put_masked(PAPORT_MASK,gcr_byte<<GPIO_PAPORT)
#define in_gcr_byte()       (gpio_get_all()&PAPORT_MASK)>>GPIO_PAPORT



uint8_t stepper_signal_puffer[256]; // Ringpuffer für Stepper Signale (256 Bytes)
volatile uint8_t stepper_signal_r_pos = 0;
volatile uint8_t stepper_signal_w_pos = 0;
volatile uint8_t stepper_signal_time = 0;
volatile uint8_t stepper_signal = 0;

volatile bool track_is_written   = false;
volatile bool no_byte_ready_send = false;
