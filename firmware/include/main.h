/////
#define LCD_LINE_COUNT  (LCD_ROWS)
#define LCD_LINE_SIZE   (LCD_COLS)


const uint16_t d64_track_offset[43] = {0,0x0000,0x0015,0x002A,0x003F,0x0054,0x0069,0x007E,0x0093,
                                         0x00A8,0x00BD,0x00D2,0x00E7,0x00FC,0x0111,0x0126,0x013B,
                                         0x0150,0x0165,0x0178,0x018B,0x019E,0x01B1,0x01C4,0x01D7,
                                         0x01EA,0x01FC,0x020E,0x0220,0x0232,0x0244,0x0256,0x0267,
                                         0x0278,0x0289,0x029A,0x02AB,0x02BC,0x02CD,0x02DE,0x02EF,
                                         0x0300,0x0311 };

const uint8_t d64_sector_count[4] = {21,        //Spuren 1-17
                                     19,        //Spuren 18-24
                                     18,        //Spuren 25-30
                                     17};       //Spuren 31-42

const uint8_t d64_track_zone[43] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,                    //Spuren 1-17
                               1,1,1,1,1,1,1,                                               //Spuren 18-24
                               2,2,2,2,2,2,                                                 //Spuren 25-30
                               3,3,3,3,3,3,3,3,3,3,3,3};                                    //Spuren 31-42

#define D64_SECTOR_SIZE (256)
uint8_t d64_sector_puffer[21*D64_SECTOR_SIZE+5];

// *** definition of GCR-structure
// see: https://ist.uwaterloo.ca/~schepers/formats/G64.TXT

#define G64_VERSION     (0x00)
#define G64_TRACKCOUNT  (42)
#define G64_TRACKSIZE   (7928)  // = 0x1ef8

const uint8_t g64_head[] = {'G','C','R','-','1','5','4','1', G64_VERSION, G64_TRACKCOUNT*2, (G64_TRACKSIZE&0xff), ((G64_TRACKSIZE>>8)&0xff)};
uint8_t g64_jumptable[8*G64_TRACKCOUNT];
/* = {                                                                  0xac, 0x02, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xa6, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x40, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x9a, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x7e, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x8e, 0x9d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0xbc, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x82, 0xdb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xfa, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x76, 0x19, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x38, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x6a, 0x57, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x76, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x5e, 0x95, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0xb4, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x52, 0xd3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0xf2, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x46, 0x11, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x30, 0x02, 0x00,
0x00, 0x00, 0x00, 0x00, 0x3a, 0x4f, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x6e, 0x02, 0x00,
0x00, 0x00, 0x00, 0x00, 0x2e, 0x8d, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0xac, 0x02, 0x00,
0x00, 0x00, 0x00, 0x00, 0x22, 0xcb, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0xea, 0x02, 0x00,
0x00, 0x00, 0x00, 0x00, 0x16, 0x09, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x28, 0x03, 0x00,
0x00, 0x00, 0x00, 0x00, 0x0a, 0x47, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x66, 0x03, 0x00,
0x00, 0x00, 0x00, 0x00, 0xfe, 0x84, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xa3, 0x03, 0x00,
0x00, 0x00, 0x00, 0x00, 0xf2, 0xc2, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xec, 0xe1, 0x03, 0x00,
0x00, 0x00, 0x00, 0x00, 0xe6, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0x04, 0x00,
0x00, 0x00, 0x00, 0x00, 0xda, 0x3e, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd4, 0x5d, 0x04, 0x00,
0x00, 0x00, 0x00, 0x00, 0xce, 0x7c, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x9b, 0x04, 0x00,
0x00, 0x00, 0x00, 0x00, 0xc2, 0xba, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0xd9, 0x04, 0x00,
0x00, 0x00, 0x00, 0x00, 0xb6, 0xf8, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00};
*/

uint8_t g64_speedtable[8*G64_TRACKCOUNT];
/* = {                                                                  0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
*/

const uint8_t g64_speedzones[] = { 3, 2, 1, 0};

#define G64_HEADERSIZE (sizeof(g64_head)+sizeof(g64_jumptable)+sizeof(g64_speedtable)) // should be 684 bytes

uint16_t g64_tracklen[G64_TRACKCOUNT];

// enough space to store 42 tracks, each 7928 bytes byte length
uint8_t g64_tracks[G64_TRACKCOUNT][G64_TRACKSIZE];

// Originale Bitraten
//Zone 0: 8000000/26 = 307692 Hz    (ByteReady 38461.5 Hz)
//Zone 1: 8000000/28 = 285714 Hz    (ByteReady 35714.25 Hz)
//Zone 2: 8000000/30 = 266667 Hz    (ByteReady 33333.375 Hz)
//Zone 3: 8000000/32 = 250000 Hz    (ByteReady 31250 Hz)

//Höhere Werte verlangsammen die Bitrate
const uint64_t timer0_values[4] = {26,28,30,32};

//const uint8_t timer0_orca0[4] = {64,69,74,79};            // Diese Werte erzeugen den genausten Bittakt aber nicht 100% (Bei 20MHz)
//const uint8_t timer0_orca0[4] = {77,83,89,95};              // Diese Werte erzeugen den genausten Bittakt aber nicht 100% (Bei 24MHz)

const uint8_t d64_sector_gap[4] = {12, 21, 16, 13}; // von GPZ Code übermommen imggen
#define HEADER_GAP_BYTES (9)

char image_filename[256]; //Maximal 256 Zeichen

uint8_t current_gui_mode;

uint8_t gui_current_line_offset;         // >0 dann ist der Name länger als die maximale Anzeigelaenge
uint8_t gui_line_scroll_pos;             // Kann zwischen 0 und fb_current_line_offset liegen
uint8_t gui_line_scroll_direction;       // Richtung des Scrollings
uint8_t gui_line_scroll_end_begin_wait;

// Alles für den FilebrowserSS
uint16_t fb_dir_entry_count = 0;         // Anzahl der Einträge im aktuellen Direktory
uint8_t fb_cursor_pos = 0;               // Position des Cursors auf dem LCD Display
uint8_t fb_window_pos = 0;               // Position des Anzeigebereichs innerhablb der Menüeinträge

uint8_t fb_current_line_offset = 0;         // >0 dann ist der Name länger als die maximale Anzeigelaenge
uint8_t fb_line_scroll_pos = 0;             // Kann zwischen 0 und fb_current_line_offset liegen
uint8_t fb_line_scroll_direction = 0;       // Richtung des Scrollings
uint8_t fb_line_scroll_end_begin_wait = 10;

uint8_t id1 = 0;    // id1 and id2 identify a floppy-disk
uint8_t id2 = 0;    // - these need to change to .. signal a disk-change or after a format...

enum {UNDEF_IMAGE, G64_IMAGE, D64_IMAGE};

// floppydisk emulation
uint8_t akt_image_type = UNDEF_IMAGE;     // 0=kein Image, 1=G64, 2=D64
uint8_t is_image_mount;

uint8_t is_wps_pin_enable = 0; // 0=WPS PIN=HiZ / 1=WPS Output
int8_t floppy_wp = 0;          // Hier wird der aktuelle WriteProtection Zustand gespeichert / 0=Nicht Schreibgeschützt 1=Schreibgeschützt

#define set_wps()   gpio_put(GPIO_WPS,1)     // 5V Level = WritePotect
#define clear_wps() gpio_put(GPIO_WPS,0)     // 0V Level = Writetable
